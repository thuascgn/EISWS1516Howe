\documentclass[11pt,oneside,a4paper,notitlepage]{article}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[margin=1.5cm]{geometry}

%kommentare, zitate, quellcode
\usepackage{verbatim}
%\fontfamily{sfdefault}
\renewcommand{\familydefault}{\sfdefault}
%
\usepackage{graphicx}
%fuer tabellen
\usepackage{tabularx}
\usepackage{tabulary}
%
%formatierung listen
\let\oldenumerate\enumerate
\renewcommand{\enumerate}{
  \oldenumerate
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}

%
%referenzen und links
\usepackage{hyperref}
\hypersetup{
colorlinks=true,
linkcolor=cyan,
urlcolor=cyan,
hidelinks=false
}
%
% 
\renewcommand{\arraystretch}{1.5}
%

\begin{document}
%
\section{Proof of Concepts - Spezifikation}
%
\subsection{Nachrichtenpriorisierung}
Es soll eine Struktur zum temporären Speichern und Ausliefern von Nachrichten gefunden werden welche die folgende Anforderungen erfüllt:

\begin{enumerate}
\item Sie ist auf einem Webserver lauffähig
\item auf dem passenden Webserver können zügig grundlegende API Funktionen implementiert werden
\item Speichern von xml/json als Key-Value Par
\begin{enumerate}
\item Priorisierung der Werte innerhalb der Speicherstruktur
%\item Sortierung durch Veränderung der gespeicherten Werte
\end{enumerate}
\end{enumerate}
\noindent
Erfolgskriterien:
\begin{enumerate}
\item Eine Priorisierung der gespeicherten Tupel muss so möglich sein das die Anfrage eines Client mit dem Aufruf /ressource?=next die korrekten Werte erhält ohne die Abfrage selbst zu manipulieren
%\item Es soll vermeiden exlizit durch alle gespeicherten Tupel zu iterieren und diese zu verändern
\item Eine Priorisierung sollte nach den Eigenschaften möglich sein: auf- und absteigend nach Eingangszeit, 
\item Die Priorisierung von 100 Tupeln solte nach 10 Durchläufen im Schnitt nicht länger als 0.1sec dauern
\end{enumerate}
\noindent

%
Fallback Szenario:\\
Die Priorisierung wird in einem seperaten Bereich/Liste/Tabelle der Datenbank abgelegt die vom Steuerungsclient manipuliert wird.
Jede Client Anfrage erzeugt einen Abruf dieser Priorisierungsstruktur welche an die Anfrage angehängt und dann ausgeführt wird.\\
\\
Alternatives Fallback Szenario:\\
Für die Priorisierung wird ein explizites Feld im Speicher angelegt. Bei einer Repriorisierung wird über alle gespeicherten Tupel 
iteriert das Priorisierungsattribut abgefragt und das explizite Feld entsprechend verändert.\\
%
\subsection{Regel Engine}
Es soll ein prototypisches Programm entwickelt werden das die grundlegenden Funktionalitäten der Regel-Engine abbildet und folgende Anforderungen erfüllt:

\begin{enumerate}
\item es muss aus einem Eingabeordner xml und/oder json Dateien eingelesen werden
\item die Informationen dieser Dateien werden auf eine Datenstruktur abgebildet
\item abhängig vom Informationen wird die Datenstruktur verändert
\item die veränderte Datenstruktur wird in einen Ausgabeordner geschrieben
\end{enumerate}
\noindent

Erfolgskriterien:\\
\begin{enumerate}
\item
\item  
\end{enumerate}
%
Fallback Szenario:\\

\\
%
\subsection{Desktop Clients}
%
Es soll ein protoypisches Programm entwickelt mit dem grundlegende Nutzungsanforderungen getestet werden und das folgende Anforderungen erfüllt:

\begin{enumerate}
\item es ist auf der Zielplatform der Clients PC mit Windows Betriebssystem lauffähig
\item es wird möglichst nativ für die Zielplatform entwickelt
\item es folgt dem WIMP Paradigma

\end{enumerate}
\item Bonus:
\begin{enumerate}
\item das Programm interagiert mit einem Webserver mit HTTP Methoden GET und POST Methoden
\end{enumerate}
\end{enumerate}
\noindent

Erfolgskriterien:
\begin{itemize}
\item es muüssen folgende Interaktionsstile(?)/pattern möglich sein: Auswahl aus Listen, Eingabe von Text, Klicken von Schaltflächen
\item zu allen Interaktionen sollen direkt sichtbare Änderungen der dargestellten Information möglich sein
\end{itemize}
\noindent

Fallback Szenario:\\
Die Clients werden als browserbasierte Funktionalität von einem Webserver ausgeliefert

\end{document}

