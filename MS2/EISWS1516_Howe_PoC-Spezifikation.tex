\documentclass[11pt,oneside,a4paper,notitlepage]{article}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[margin=1.5cm]{geometry}

%kommentare, zitate, quellcode
\usepackage{verbatim}
%\fontfamily{sfdefault}
\renewcommand{\familydefault}{\sfdefault}
%
\usepackage{graphicx}
%fuer tabellen
\usepackage{tabularx}
\usepackage{tabulary}
%
%formatierung listen
\let\oldenumerate\enumerate
\renewcommand{\enumerate}{
  \oldenumerate
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}

%
%referenzen und links
\usepackage{hyperref}
\hypersetup{
colorlinks=true,
linkcolor=cyan,
urlcolor=cyan,
hidelinks=false
}
%
% 
\renewcommand{\arraystretch}{1.5}
%

\begin{document}

\begin{comment}
Die Proof of Concepts lassen sich evtl. aus den Risiken ableiten. Für die Spezifizierung der Proof of Concepts müssen jeweils Exit- und Failkriterien beschrieben werden. D.h. es werden konkrete Bedingungen spezifiziert, die besagen in welchem Fall ein Proof of Concept als "erfolgreich" oder als "nicht erfolgreich" gilt. Falls ein Proof of Concept gescheitert ist, muss man sich im Vorfeld Alternativen/Fallbacks überlegen, die anstelle der ursprünglich angedachten Vorgehensweise herangezogen werden könnten. Die Durchführung eines Proof of Concepts muss dokumentiert werden. 
\end{comment}


%
\section{Proof of Concepts - Spezifikation}
%
%
\subsection{Regel Engine}

Um sicherzustellen das die grundlegende Funktionalität eines Alleinstellungsmerkmals, der Regel Engine, gewährleistet ist soll ein prototypisches Programm entwickelt werden das die grundlegenden Funktion der Regel-Engine abbildet.\\
Dazu werden aus einem Eingabeverzeichnis zwei oder drei xml Dateien mit Dokumentdaten, Regelbedingungen und Attributierungen eingelesen. Deren Inhalte werden auf eine Datenstruktur abgebildet und miteinander verglichen. Abhängig vom Vergleich wird eine zu Exportdatenstruktur gefüllt, verändert und darauf in einen Ausgabeordner geschrieben.
\\
Anforderungen:
\begin{enumerate}
\item das Programm horcht auf einen Importverzeichnis
\item wenn ein neues Quellverzeichnis im Importverzeichnis vorhanden ist, werden, sehr zeitnah, die enthaltenen xml Dateien eingelesen
\item die für eine Regelanwendung nötige Anzahl der zu importierenden Dateien wird verarbeitet
\item Ausgangsdaten werden in entsprechende Datenstrukturen überführt
\item Attributierungen werden korrekt nach Regelbedingungen ausgeführt
\item die Exportdatenstruktur wird als xml Datei in einem eigenen Verzeichnis in einem Exportverzeichnis gespeichert
\item die Importverzeichnis der verarbeiteten Dateien wird gelöscht
\end{enumerate}
\noindent
Erfolgskriterium: Erfüllungsgrad der Anforderungen\\
Fallback Szenario:\\
Da die automatisierte Regelanwendung eine Kernfunktionalität des Systems ist, gibt es keine adäquate funktionale Alternative. Lediglich bei der Verarbeitung der Datenstrukturen von Ausgangsdaten, Regelbedingunen und Attributierungen könnten alternative Lösungen entwickelt werden.
%
%
\subsection{Desktop Clients}
%
Es soll ein protoypisches Programm für den WIMP Interaktionsstil entwickelt werden mit dem sichergestellt wird das bei der Implementierung wichtiger Pattern, zb. nach Tidwell \href{}{}, 
und Stile eine grundlegende Menge an Interaktionselementen ohne technische Probleme genutzt werden kann.
\\
Anforderungen:
\begin{enumerate}
\item das Programm ist auf der Zielplatform der Clients PC mit Windows Betriebssystem lauffähig
\item es folgt dem WIMP Paradigma
\item Interaktion soll mit folgenden Interaktionselementen möglich sein:
\begin{enumerate}
\item Buttons (Schaltflächen)
\item Formularein von Text und Zahlen 
\item Checkboxen
\item Radiobuttons
\item Auswahl aus Listen
\item Auswahl aus DropDown Menus
\end{enumerate}
\item die interagierende Person soll auf Klick eines Buttons eine Zusammenfassung seiner Eingabe erhalten, dies dient als Simulation der Zusammenführung der Daten die der Client an ein anderes System sendet
\end{enumerate}
\noindent
Erfolgskriterium: Erfüllungsgrad der Anforderungen\\
Fallback Szenario:\\
Die Clients werden als browserbasierte Funktionalität von einem Webserver ausgeliefert.
%
%
\subsection{Nachrichtenpriorisierung}
Zur Sicherung der wichtigen Funktionalität der Nachrichtenpriorisierung soll eine Struktur zum Speichern und Abrufen von Nachrichten gefunden werden die eine Priorisierung der gespeicherten Nachrichten ermöglicht.

Erfolgskriterien:
\begin{enumerate}
\item es soll eine In-Memory Datenbank verwendet werden
\item um größeren Einarbeitungsaufwand zu vermeiden muss die Datenbank den Projektdurchführenden bekannt sein
\item die Priorisieung soll nach Attributen der Nachrichten mit dem Datentyp String möglich sein
\item Priorisierung und Abfrage durch einen Client müssen voneinander gekapselt sein, genauer
\begin{enumerate}
\item die Priorisierung der Nachrichten darf nicht in die Verarbeitung der Anfrage eines Client injiziert werden
\item bei der Verarbeitung einer Client Anfrage sollte vor der Abfrage der Datenstruktur keine separate Priorisierungsstruktur angefragt werden
\end{enumerate}
\item die Datenbank muss adäquate Auswahl- und Sortierungsoperationen zur Verfügung stellen, insbesondere muss vermieden werden für die Priorisierung 
\begin{enumerate}
\item eine eigenständig Struktur zur Sortierung entwickeln zu müssen und
\item explizit durch alle Nachrichten zu iterieren und die gespeicherten Nachrichten zu verändern
\end{enumerate}
\item ...
\end{enumerate}
\noindent

Erfolgskriterium: Erfüllungsgrad der Anforderungen\\
%
Fallback Szenario:\\
Die Priorisierung wird über ein SQL Variante realisiert, wobei in Kauf genommen wird das diese nicht unbedingt mit überschaubarem Aufwand als 
In-Memory Datenbank betrieben werden kann.

 
%
%
\subsection{Client Kommunikation}

Der im PoC Desktop Cilent entwickelt e Client sollte mit einer Web Api kommunizieren können.

\begin{itemize}
\item das Programm interagiert mit einem Webserver HTTP Methoden GET und POST Methoden
\end{enumerate}
\end{enumerate}

%
%
\subsection{Nachrichtenpriorisierung 2}
Es wird eine mit einer SQL Variante die Anforderungen an die Priorisierung der Nachrichtenstruktur getestet.

Erfolgskriterien:
\begin{enumerate}
\item es kann eine In-Memory Datenbank verwendet werden
\item um größeren Einarbeitungsaufwand zu vermeiden muss die Datenbank den Projektdurchführenden bekannt sein
\item Priorisierung und Abfrage durch einen Client müssen voneinander gekapselt sein, genauer
\begin{enumerate}
\item die Priorisierung der Nachrichten darf nicht in die Verarbeitung der Anfrage eines Client injiziert werden
\item bei der Verarbeitung einer Client Anfrage sollte vor der Anfrage keine seperate Priorisierungsstruktur angefragt werden
\end{enumerate}
\end{enumerate}
\noindent
%
Erfolgskriterien: Erfüllungsgrad der Anforderungen\\
%
%
Fallback Szenario:\\


\end{document}

